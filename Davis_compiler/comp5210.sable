Package comp5210;

Helpers
//all digits
    digit = ['0' .. '9'] ;

//all ascii characters
    ascii_char = [32 .. 127] ;

//all ascii characters except the quotes
	no_quote = 32|33|[35 .. 127];

//all letters
    letter = [['a' .. 'z'] + ['A' .. 'Z']] ;
	
//end of line
	eol = 10|13 ; 
	
Tokens

//Reserved Words
	if = 'if';
	else = 'else';
	class = 'class';
	constantinople = 'const';
	public = 'public';
	private = 'private';
	return = 'return';
	while = 'while';
	mainmeth = 'main';
	void_methods = 'void';

//Math operators
	left_parent = '(';
	right_parent = ')';
	times = '*';
	divide = '/';
	plus = '+';
	minus = '-';
	
//Boolean operators
	andy = '&&'|'and';
	or_nah = '||'|'or';
	nah = '!'|'not';
	equators = '==';
	noteqs = '!=';
	great_than_eq = '>=';
	less_than_eq = '<=';
	greater = '>';
	lesser = '<';

//assignment	
	assignments = '=';
	
//other line stuff
	line_ender = ';';
	left_bracket = '[';
	right_bracket = ']';	
	left_curly = '{';
	right_curly = '}';
	comma = ',';

//single line comments
	comment = '//' ascii_char*;
	
//strings
	sillystrings = '"' ((no_quote)* '\"'?)* '"';
	
//float literals
	rootbeerfloats = (digit+ '.' digit+ 'e' '-'? digit+)|(digit+ '.' digit+);

//integer literals
	ints = digit+;

//variable name and other identifiers	
	var_names = (letter+ '_'?)+;

//whitespace
	whitespace = (' '|9|10|13)+;

IgnoredTokens
	whitespace,
	comment;
	
Productions
	//Main progam grammar that calls declarations of variables and methods
	program = declarations meth_decs;
	
	//Recursive grammar that allows for multiple statements to be written
	statements = {recurs} statements statement | {one} statement;
	statement = {ifs} if_state | {meth} methods_call | {whiles} while_state | {decl} declaration | {ass} assign ;
	
	//Statements to handle if, else, and while
	if_state = {ifs} if left_parent express_logic right_parent left_curly statements right_curly | {elses} if left_parent express_logic right_parent [lcurl1]:left_curly [ifstates]:statements [rcurl1]:right_curly else [lcurl2]:left_curly [elsestates]:statements [rculr2]:right_curly;
	while_state = while express_logic left_curly statements right_curly;
	
	//Grammar to handle method calls, recursively allows for multiple actual parameters
	methods_call = {params} var_names left_parent actual_params right_parent line_ender | {noparams} var_names left_parent right_parent line_ender;
	actual_params = {recur} actual_params comma actual_consts | {one} actual_consts;
	actual_consts = {expressions} express_logic | {strings} sillystrings;
	
	//Grammar for arrays
	//arrays = left_bracket express_logic right_bracket;
	
	//Recursive grammar that allows for multiple methods to be declared
	meth_decs = {recurse} meth_decs methods_decl| {one} methods_decl;
	methods_decl = {params} void_methods var_names left_parent formal_params right_parent left_curly statements right_curly | {noparams} void_methods var_names left_parent right_parent left_curly statements right_curly | {main} void_methods mainmeth left_parent right_parent left_curly statements right_curly | {emptypara} void_methods var_names left_parent formal_params right_parent left_curly right_curly | {emptynopara} void_methods var_names left_parent right_parent left_curly right_curly | {emptymain} void_methods mainmeth left_parent right_parent left_curly right_curly;
	formal_params = {recur} formal_params comma formal_consts | {one} formal_consts;
	formal_consts = {vars} [id1]:var_names [id2]:var_names | {arr} [id1]:var_names [id2]:var_names left_bracket right_bracket;
	
	//Grammar to handle boolean and math expressions
	express_logic = {or} [ops1]:express_comp or_nah [ops2]:express_comp | {and} [ops1]:express_comp andy [ops2]:express_comp | {not}  nah express_comp| {comp} express_comp;
	express_comp = {gte} [ops1]:express_as great_than_eq [ops2]:express_as  | {lte} [ops1]:express_as less_than_eq [ops2]:express_as  | {lt} [ops1]:express_as lesser [ops2]:express_as  | {gt} [ops1]:express_as greater [ops2]:express_as  | {eqs} [ops1]:express_as equators [ops2]:express_as | {noteqs} [ops1]:express_as noteqs [ops2]:express_as | {math} express_as;
	express_as = {add} express_as plus express_md | {sub} express_as minus express_md | {md} express_md;
	express_md = {mult} express_md times express_parent | {div} express_md divide express_parent | {parent} express_parent;
	express_parent = {parent} left_parent express_logic right_parent | {consts} express_consts;
	express_consts = {negvar} minus var_names | {negint} minus ints | {negflo} minus rootbeerfloats | {var} var_names | {ints} ints | {flo} rootbeerfloats | {array} var_names left_bracket express_logic right_bracket;
	
	//Recursive grammar that allows for multiple declarations to be made
	declarations = {declarations} declarations declaration | {declaration} declaration;
	declaration = {constants} constantine | {vars} decl_options line_ender;
	decl_options = {var} [type]:var_names [var]:var_names | {arr} [type]:var_names [var]:var_names left_bracket ints right_bracket;
	
	//Grammar that allows for constants to be initialized
	constantine = constantinople [id1]:var_names [id2]:var_names assignments num_consts line_ender;
	num_consts = {posint} ints | {negint} minus ints | {posflo} rootbeerfloats | {negflo} minus rootbeerfloats;
	
	//Statement that handles assignments
	assign = {var} var_names assignments express_logic line_ender | {arr} var_names left_bracket [array_bound]:express_logic right_bracket assignments [expression]:express_logic line_ender;